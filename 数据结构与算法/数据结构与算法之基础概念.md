[此文在掘金上的地址](https://juejin.im/post/5e9cf6f8f265da47c8013cd4)

## 前言

> 一名优秀的程序员，必然要有扎实的**数据结构与算法**基础。以下是笔者梳理的数据结构与算法系列，欢迎大家阅读指正，同时也希望对大家有所帮助。
> 1. [数据结构与算法之基础概念](https://github.com/ConstantCody/blogs/blob/master/数据结构与算法/数据结构与算法之基础概念.md)
> 2. [数据结构与算法之基础概念](https://github.com/ConstantCody/blogs/blob/master/数据结构与算法/数据结构与算法之基础概念.md)
> 3. 未完待续...

作为这个系列的第一篇文章，本文主要介绍的是一些基本概念（**理解为主**），下面开始正文。

## 1 数据结构

### 1.1 数据

在计算机科学中，数据是指所有能输入到计算机并被计算机程序处理的符号的介质的总称，是用于输入电子计算机进行处理，具有一定意义的数字、字母、符号和模拟量等的通称。数据是信息的载体，它能够被计算机识别、存储和加工处理，是计算机程序加工的"原料"。

数据的范畴包括：整数、实数、字符串、图像和声音等。可以用一幅图简单说明一下数据的构成

![](https://user-gold-cdn.xitu.io/2020/4/22/171a270ed18e0839?w=1396&h=664&f=png&s=54192)

图中的各个名词说明如下：

* 数据项：是数据的不可分割的最小单位，它具有独立含义，在不同的场景有不同的称谓，如字段、域、属性等
* 数据元素：是数据的基本单位，由数据项组成。数据元素也称元素、结点、顶点、记录。一个数据元素可以由若干个数据项（也可称为字段、域、属性）组成。
* 数据对象：是性质相同的数据元素的集合，是数据的子集。

> 为了帮助大家记忆，假设数据库中有一张学生表，里面存储着一些学生信息，每个学生都有姓名、年龄、性别、班级等属性。对比上面的概念描述，这张学生表可以当作是一个数据对象，每个学生对应着数据元素，那么学生的姓名等属性就是数据项。

### 1.2 数据结构

数据结构（Data Structure）是计算机**存储、组织**数据的方式，它描述的是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为**逻辑结构**和**物理结构（也叫存储结构）**。通常情况下，**精心选择的数据结构可以带来更高的运行或者存储效率。**

数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。

#### 1.2.1 逻辑结构

数据的逻辑结构反映的是数据元素之间的逻辑关系，这个**逻辑关系**是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构主要包括：

* 集合结构：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；
* 线性结构：数据结构中的元素存在一对一的相互关系；
* 树形结构：数据结构中的元素存在一对多的相互关系；
* 图形结构：数据结构中的元素存在多对多关系。

如图所示：

![](https://user-gold-cdn.xitu.io/2020/4/22/171a0c95c02735e4?w=1636&h=1358&f=png&s=178392)

#### 1.2.2 物理结构

物理结构又叫存储结构，指数据的逻辑结构在计算机存储空间的存放形式（又称映像）。主要有顺序存储和链式存储两种，两者的区别是数据元素之间的地址空间是否是连续的。

如图所示：

![](https://user-gold-cdn.xitu.io/2020/4/22/171a10dbb9469871?w=1170&h=728&f=png&s=61313)

#### 1.2.3 常用的数据结构

程序设计中常用的数据结构有：

1. 数组（Array）

**数组** 是将具有相同类型的若干变量有序地组合在一起的集合。数组可以说是最基本的数据结构，逻辑上它是属于线性结构的。

2. 链表（Linked List）

**链表** 是一种数据元素按照链式存储结构进行存储的数据结构。它由一系列数据节点（Node）构成，每个节点包括**数据域和指针域**两部分，具有在物理上存在非连续的特点。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。

3. 栈（Stack）

**栈** 是一种特殊的线性表，它只能在表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则（LIFO）来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。

4. 队列（Queue）

**队列** 和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。队列按照先进先出的原则（FIFO）来存储数据。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。

5. 树（Tree）

**树**是典型的非线性结构。在树结构中，有且仅有一个根节点，该节点没有前驱节点；其他节点都有且仅有一个前驱节点，而且可以有两个后继节点。

6. 图（Graph）

**图**是另一种非线性数据结构。在图结构中，数据节点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。

7. 堆（Heap）

**堆**是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根节点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。

8. 散列表（Hash）

**散列表** 源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

## 2 算法

**算法（Algorithm）** 是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令。它代表着用系统的方法描述解决问题的策略机制。

### 2.1 算法的五要素

一个算法应该具有以下五个重要的特征：

1. 有穷性（Finiteness）：指算法必须能在执行有限个步骤之后终止；
2. 确切性（Definiteness）：算法的每一步骤必须有确切的定义；
3. 输入项（Input）：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
4. 输出项（Output）：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
5. 可行性（Effectiveness）：也称为有效性，即每个计算步骤都可以在有限时间内完成。

### 2.2 算法的评定

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。

一个算法的评价主要从以下几个方面来考虑：

1. 时间复杂度：指执行算法所需要的计算工作量，一般用大O表示法表示，记做O(f(n))。如O(1)、O(n)等。
    * 问题的规模n越大，算法执行的时间的增长率与f(n)的增长率正相关
2. 空间复杂度：指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。
    * 同时间复杂度相比，空间复杂度的分析要简单得多。
3. 正确性：即算法的执行结果必须是正确的。
4. 可读性：指一个算法可供人们阅读的容易程度。
5. 健壮性：也叫容错性，指的是算法对不合理数据输入的反应能力和处理能力。

> 注意：通常说的算法复杂度就是时间复杂度。

#### 2.2.1 常见的时间复杂度

这里用一张表格说明：

|执行的次数函数f(n)|时间复杂度|术语|
|---|---|---|
|12|O(1)|常数阶|
|2n+3|O(n)|线性阶|
|3n<sup>2</sup>+2n+1|O(n<sup>2</sup>)|平方阶|
|5log<sub>2</sub>n+20|O(logn)|对数阶|
|2n+3nlog<sub>2</sub>n+19|O(nlogn)|nlogn阶|
|4n<sup>3</sup>+2n<sup>2</sup>+10|O(n<sup>3</sup>)|立方阶|
|2<sup>n</sup>+3n+1|O(2<sup>n</sup>)|指数阶|

一般来说，各个阶的比较如下：

O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

> 注意：你设计的算法要尽可能地高效，需要协调好时间复杂度和空间复杂度，一定要避免指数阶、阶乘的出现！

#### 2.2.2 举几个栗子

针对上面的表格，可以举几个栗子帮助大家消化：

1. O(1)
````c
int add(int n) {
    int i = 10;     // 执行1次
    i += n;         // 执行1次
    return i;       // 执行1次
}
````

可见执行次数为3次，与n无关。这也就是常数阶的特点，其时间复杂度为**O(1)**。

2. O(n)
````c
int add(int n) {
    int sum = 0;                            // 执行1次
    for (int i = 0; i < n; i++) sum++;      // 执行n次
    for (int i = 0; i < n; i++) sum++;      // 执行n次
    return sum;                             // 执行1次
}
````

共执行`2n+2`次，线性阶，其时间复杂度是**O(n)**。

3. O(n<sup>2</sup>)

````c
int add(int n) {
    int sum = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            sum++;
    return sum;
}
````

执行次数为`n*n+2`次，是平方阶，时间复杂度是**O(n<sup>2</sup>)**。

> 在双层循环的基础上再嵌套一层 **n次** 的循环，就是立方阶了。

4. O(logn)
````c
void logn(int n) {
    int i = 1;
    while (i <= n) {
        i = i*2;
    }
}
````
如果记while循环执行的次数为x，则有**2<sup>x</sup> = n**，所以**x = log<sub>2</sub>n**，也就是对数阶，因此时间复杂度为**O(logn)**。

> 注意：对数阶是忽略对数的底数的，即无论底数是2、3，还是10等等，其时间复杂度都是O(logn)。
>
> 对whild循环外加一层n次的循环，就是O(nlogn)了。

#### 2.2.3 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。

同样是用大O表示法，常用的空间复杂度有：O(1)、O(n)、O(n<sup>2</sup>)。接下来举几个简单的栗子看看

1. O(1)
````c
int add(int n) {
    int i = 1;
    int j = 2;
    int k = 3;
    ++i;
    ++j;
    --k;
    return i + j + k + n;
}
````
代码中所分配的临时空间的数量（i、j、k）与n并无关系，所以它的空间复杂度是O(1)。

2. O(n)
````c
void function(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
        array[i] = i;
    }
}
````
这段代码中，创建了一个整型数组array[n]，需要的临时空间数量是n个int空间，所以其空间复杂度是O(n)。

> 空间复杂度O(n<sup>2</sup>)只需要创建一个n*n的二维数组即可，这里不作赘述。

#### 2.2.4 算法小结

**算法的目的是为了更有效的处理数据，提高数据运算效率**。对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。实际开发中，往往需要开发者自己衡量，找到时间复杂度和空间复杂度的最优平衡点。

## 3 总结

数据结构和算法是密不可分的，总的来说，好的数据结构可以带来更高的运行或者存储效率，同时算法的设计取决于数据的逻辑结构，而算法的实现又依赖于指定的存储结构。

这里用一张思维导图总结一下本文的知识点

![](https://user-gold-cdn.xitu.io/2020/4/23/171a4b869126324e?w=1750&h=1552&f=png&s=244952)

## 4 参考资料

* [数据结构 @百度百科](https://baike.baidu.com/item/数据结构/1450)
* [算法 @百度百科](https://baike.baidu.com/item/算法)

## PS

* [原文链接](https://juejin.im/post/5e9cf6f8f265da47c8013cd4)，转载请注明出处！
